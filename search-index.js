var N=null,E="",T="t",U="u",searchIndex={};
var R=["An owning reference.","Typedef of a owning reference that uses a…","Typedef of a mutable owning reference that uses a…","Erased","The type of handle to be encapsulated by the OwningHandle.","Given an appropriately-long-lived pointer to ourselves,…","owningref","Creates a new owning reference from a owner initialized to…","new_assert_stable_address","Like `new`, but doesn’t require `O` to implement the…","owningrefmut","map_owner","Converts `self` into a new owning reference with a…","map_owner_box","Converts `self` into a new owning reference where the…","erase_owner","Erases the concrete base type of the owner with a trait…","as_owner","A reference to the underlying owner.","into_owner","Discards the reference and retrieves the owner.","Create a new OwningHandle. The provided callback will be…","result","try_from","try_into","borrow_mut","type_id","ordering","partial_cmp","deref_mut","formatter","IntoErased","ToHandle","ToHandleMut","OwningRef","OwningRefMut","OwningHandle","An unsafe marker trait for types that deref to a stable…","An unsafe marker trait for types where clones deref to the…"];

searchIndex["owning_ref"]={"doc":R[0],"i":[[8,"StableAddress","owning_ref",R[37],N,N],[8,"CloneStableAddress",E,R[38],N,N],[3,R[34],E,R[0],N,N],[3,R[35],E,"An mutable owning reference.",N,N],[3,R[36],E,"`OwningHandle` is a complement to `OwningRef`. Where…",N,N],[6,"BoxRef",E,"Typedef of a owning reference that uses a `Box` as the…",N,N],[6,"VecRef",E,"Typedef of a owning reference that uses a `Vec` as the…",N,N],[6,"StringRef",E,"Typedef of a owning reference that uses a `String` as the…",N,N],[6,"RcRef",E,"Typedef of a owning reference that uses a `Rc` as the owner.",N,N],[6,"ArcRef",E,"Typedef of a owning reference that uses a `Arc` as the…",N,N],[6,"RefRef",E,"Typedef of a owning reference that uses a `Ref` as the…",N,N],[6,"RefMutRef",E,"Typedef of a owning reference that uses a `RefMut` as the…",N,N],[6,"MutexGuardRef",E,"Typedef of a owning reference that uses a `MutexGuard` as…",N,N],[6,"RwLockReadGuardRef",E,R[1],N,N],[6,"RwLockWriteGuardRef",E,R[1],N,N],[6,"BoxRefMut",E,"Typedef of a mutable owning reference that uses a `Box` as…",N,N],[6,"VecRefMut",E,"Typedef of a mutable owning reference that uses a `Vec` as…",N,N],[6,"StringRefMut",E,"Typedef of a mutable owning reference that uses a `String`…",N,N],[6,"RefMutRefMut",E,"Typedef of a mutable owning reference that uses a `RefMut`…",N,N],[6,"MutexGuardRefMut",E,R[2],N,N],[6,"RwLockWriteGuardRefMut",E,R[2],N,N],[6,"ErasedBoxRef",E,"Typedef of a owning reference that uses an erased `Box` as…",N,N],[6,"ErasedRcRef",E,"Typedef of a owning reference that uses an erased `Rc` as…",N,N],[6,"ErasedArcRef",E,"Typedef of a owning reference that uses an erased `Arc` as…",N,N],[6,"ErasedBoxRefMut",E,"Typedef of a mutable owning reference that uses an erased…",N,N],[8,R[3],E,"Helper trait for an erased concrete type an owner…",N,N],[8,R[31],E,"Helper trait for erasing the concrete type of what an…",N,N],[16,R[3],E,"Owner with the dereference type substituted to `Erased`.",0,N],[10,"into_erased",E,"Perform the type erasure.",0,[[]]],[8,R[32],E,"Trait to implement the conversion of owner to handle for…",N,N],[16,"Handle",E,R[4],1,N],[10,"to_handle",E,R[5],1,[[]]],[8,R[33],E,"Trait to implement the conversion of owner to mutable…",N,N],[16,"HandleMut",E,R[4],2,N],[10,"to_handle_mut",E,R[5],2,[[]]],[11,"new",E,R[7],3,[[["o"]],["self"]]],[11,R[8],E,R[9],3,[[["o"]],["self"]]],[11,"map",E,"Converts `self` into a new owning reference that points at…",3,[[["f"]],[[R[6]],["sized"]]]],[11,"try_map",E,"Tries to convert `self` into a new owning reference that…",3,[[["f"]],[[R[6]],[R[22],[R[6]]]]]],[11,R[11],E,R[12],3,[[["f"]],[R[6]]]],[11,R[13],E,R[14],3,[[],[[R[6],["box"]],["box"]]]],[11,R[15],E,R[16],3,[[],[R[6]]]],[11,R[17],E,R[18],3,[[["self"]],["o"]]],[11,R[19],E,R[20],3,[[],["o"]]],[11,"new",E,R[7],4,[[["o"]],["self"]]],[11,R[8],E,R[9],4,[[["o"]],["self"]]],[11,"map",E,"Converts `self` into a new shared owning reference that…",4,[[["f"]],[[R[6]],["sized"]]]],[11,"map_mut",E,"Converts `self` into a new mutable owning reference that…",4,[[["f"]],[[R[10]],["sized"]]]],[11,"try_map",E,"Tries to convert `self` into a new shared owning reference…",4,[[["f"]],[[R[6]],[R[22],[R[6]]]]]],[11,"try_map_mut",E,"Tries to convert `self` into a new mutable owning…",4,[[["f"]],[[R[22],[R[10]]],[R[10]]]]],[11,R[11],E,R[12],4,[[["f"]],[R[10]]]],[11,R[13],E,R[14],4,[[],[["box"],[R[10],["box"]]]]],[11,R[15],E,R[16],4,[[],[R[10]]]],[11,R[17],E,R[18],4,[[["self"]],["o"]]],[11,"as_owner_mut",E,"A mutable reference to the underlying owner.",4,[[["self"]],["o"]]],[11,R[19],E,R[20],4,[[],["o"]]],[11,"new",E,"Create a new `OwningHandle` for a type that implements…",5,[[["o"]],["self"]]],[11,"new_mut",E,"Create a new mutable `OwningHandle` for a type that…",5,[[["o"]],["self"]]],[11,"new_with_fn",E,R[21],5,[[["o"],["f"]],["self"]]],[11,"try_new",E,R[21],5,[[["o"],["f"]],[R[22]]]],[11,R[17],E,"A getter for the underlying owner.",5,[[["self"]],["o"]]],[11,R[19],E,"Discards the dependent object and returns the owner.",5,[[],["o"]]],[11,"to_owned",E,E,3,[[["self"]],[T]]],[11,"clone_into",E,E,3,[[["self"],[T]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into",E,E,3,[[],[U]]],[11,R[23],E,E,3,[[[U]],[R[22]]]],[11,R[24],E,E,3,[[],[R[22]]]],[11,"borrow",E,E,3,[[["self"]],[T]]],[11,R[25],E,E,3,[[["self"]],[T]]],[11,R[26],E,E,3,[[["self"]],["typeid"]]],[11,"from",E,E,4,[[[T]],[T]]],[11,"into",E,E,4,[[],[U]]],[11,R[23],E,E,4,[[[U]],[R[22]]]],[11,R[24],E,E,4,[[],[R[22]]]],[11,"borrow",E,E,4,[[["self"]],[T]]],[11,R[25],E,E,4,[[["self"]],[T]]],[11,R[26],E,E,4,[[["self"]],["typeid"]]],[11,"from",E,E,5,[[[T]],[T]]],[11,"into",E,E,5,[[],[U]]],[11,R[23],E,E,5,[[[U]],[R[22]]]],[11,R[24],E,E,5,[[],[R[22]]]],[11,"borrow",E,E,5,[[["self"]],[T]]],[11,R[25],E,E,5,[[["self"]],[T]]],[11,R[26],E,E,5,[[["self"]],["typeid"]]],[11,"as_ref",E,E,3,[[["self"]],[T]]],[11,"as_ref",E,E,4,[[["self"]],[T]]],[11,"clone",E,E,3,[[["self"]],["self"]]],[11,R[28],E,E,3,[[["self"]],[[R[27]],["option",[R[27]]]]]],[11,R[28],E,E,4,[[["self"]],[[R[27]],["option",[R[27]]]]]],[11,"eq",E,E,3,[[["self"]],["bool"]]],[11,"eq",E,E,4,[[["self"]],["bool"]]],[11,"from",E,E,3,[[["o"]],["self"]]],[11,"from",E,E,4,[[["o"]],["self"]]],[11,"from",E,E,3,[[[R[10]]],["self"]]],[11,"cmp",E,E,3,[[["self"]],[R[27]]]],[11,"cmp",E,E,4,[[["self"]],[R[27]]]],[11,"as_mut",E,E,4,[[["self"]],[T]]],[11,"deref",E,E,5,[[["self"]]]],[11,"deref",E,E,3,[[["self"]],[T]]],[11,"deref",E,E,4,[[["self"]],[T]]],[11,R[29],E,E,5,[[["self"]]]],[11,R[29],E,E,4,[[["self"]],[T]]],[11,"hash",E,E,3,[[["self"],["h"]]]],[11,"hash",E,E,4,[[["self"],["h"]]]],[11,"fmt",E,E,3,[[["self"],[R[30]]],[[R[22],["error"]],["error"]]]],[11,"fmt",E,E,4,[[["self"],[R[30]]],[[R[22],["error"]],["error"]]]],[11,"fmt",E,E,6,[[["self"],[R[30]]],[[R[22],["error"]],["error"]]]],[11,"borrow",E,E,3,[[["self"]],[T]]]],"p":[[8,R[31]],[8,R[32]],[8,R[33]],[3,R[34]],[3,R[35]],[3,R[36]],[8,R[3]]]};
searchIndex["stable_deref_trait"]={"doc":"This module defines an unsafe marker trait, StableDeref,…","i":[[8,"StableDeref","stable_deref_trait",R[37],N,N],[8,"CloneStableDeref",E,R[38],N,N]],"p":[]};
initSearch(searchIndex);addSearchOptions(searchIndex);